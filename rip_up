#!/usr/bin/env bash

# Update Rust, pull changes from ripgrep upstream; rebuild, if necessary
# Tested with Bash 4.4 and Rust nightly

################################################################################

# # Trace live execution
# set -o xtrace

# Calm down a bit
set +o errexit

# Source Bash utilities, if possible
export bash_utils="${HOME:=/home/slaiyer}/bin/bash_utils.sh"
# shellcheck source=/home/slaiyer/bin/bash_utils.sh
if [[ ! -e "${bash_utils}" ]] || ! . "${bash_utils}"; then
    printf '[ERROR] Could not source %s\n' "${bash_utils}" 1>&2
    exit 1
fi

# Print help message
usage() {
    local -a order
    local help_fmt="${sqo}-h${sqc}"
    local help_msg="${d}Print this help message${n}"
    order+=( "${help_fmt}" )
    local verb_fmt="${sqo}-v 0..${u}2${n}${sqc}"
    local verb_msg="${d}Control output verbosity${n}"
    order+=( "${verb_fmt}" )
    local force_fmt="${sqo}-f${sqc}"
    local force_msg="${d}Force ripgrep rebuild${n}"
    order+=( "${force_fmt}" )
    local src_fmt="${sqo}-d ${i}<git_dir>${n}${sqc}"
    local src_msg="${d}Specify path to ripgrep git local directory${n}"
    order+=( "${src_fmt}" )
    local upstream_fmt="${sqo}-u ${i}<upstream>${n}${sqc}"
    local upstream_msg="${d}Specify ripgrep upstream, e.g. 'origin/master'${n}"
    order+=( "${upstream_fmt}" )
    local nostrip_fmt="${sqo}-p${sqc}"
    local nostrip_msg="${d}Do not strip executable post build step${n}"
    order+=( "${nostrip_fmt}" )

    local -A prog_params=(
        ["${help_fmt}"]="${help_msg}"
        ["${verb_fmt}"]="${verb_msg}"
        ["${force_fmt}"]="${force_msg}"
        ["${src_fmt}"]="${src_msg}"
        ["${upstream_fmt}"]="${upstream_msg}"
        ["${nostrip_fmt}"]="${nostrip_msg}"
    )

    printf 'Usage:\n\t%s\n' "${b}$(basename -- "${0}")${n}" 1>&2

    local text=''
    local key=''
    for idx in "${!order[@]}"; do
        key="${order["${idx}"]}"
        text="${text}${key}|${prog_params[${key}]}"$'\n'
    done

    printf '%s' "${text}" \
        | column -t -s '|' \
        | sed -u 's/^/\t\t/' 1>&2
}

# Update Rust, if possible
rust_update() {
    log_msg 'INFO' 'Checking for updates to Rust'

    # Duplicate stdout
    exec 3>&1

    # Copy rustup output to stdout before piping to grep
    unbuffer rustup update 2>&1 \
        | tee /dev/fd/3 \
        | grep -q -F 'updated'

    # Save pipe status codes
    local -a pipe_status=( "${PIPESTATUS[@]}" )

    # Close duplicated file descriptor
    exec 3>&-

    # Return failure if any command in the pipeline failed
    local code=1
    for idx in "${!pipe_status[@]}"; do
        code="${pipe_status[idx]}"
        if (( "${code}" != 0 )); then
            log_msg \
                'INFO' \
                "rustup pipeline command #$(( idx + 1 )) exited with ${code}"
            return "${code}"
        fi
    done

    # Return success by default
    return 0
}

# Pull fresh changes from ripgrep upstream, rebuild, and run tests
ripgrep_rebuild() { # Parameters: strip_bin
    log_msg 'INFO' 'Building ripgrep'
    env RUSTFLAGS='-C target-cpu=native' \
        cargo build --release --features 'simd-accel avx-accel' \
            || { log_msg 'ERROR' 'Cargo build failed'; exit 1; }

    log_msg 'INFO' 'Testing new build'
    cargo test --all \
        || { log_msg 'WARN' 'Cargo test failed'; exit 1; }

    log_msg 'INFO' 'Build successful' 'force'
    local exe_path='./target/release/rg'
    "${exe_path}" --version \
        || { log_msg 'WARN' 'Could not query ripgrep version'; exit 1; }

    log_msg 'INFO' 'Stripping executable'
    local strip_bin="${1:-strip}"
    [[ "${strip_bin}" == 'strip' ]] \
        && {
            log_msg 'INFO' "Before strip:"$'\n\t'"$(ls -lF "${exe_path}")"
            strip -p -s "${exe_path}"
            log_msg 'INFO' "After strip:"$'\n\t'"$(ls -lF "${exe_path}")"
        }
}

# Pull and rebase from upstream
repo_pull_rebase() { # Parameters: upstream
    log_msg 'INFO' 'Pulling updates from ripgrep upstream'

    # Change 'upstream/branch' to 'upstream branch'
    #     and tokenize into array elements
    local upstream="${1:-origin/master}"
    local -a upstream_split
    # shellcheck disable=SC2086
    read -r -a upstream_split <<< ${upstream/\// }

    git pull "${upstream_split[@]}" --rebase \
        || { log_msg 'ERROR' 'Git pull failed'; exit 1; }
}

# Check if upstream has changes
repo_check() { # Parameters: upstream
    log_msg 'INFO' 'Checking ripgrep Git local against upstream'

    local git_current_branch='@{0}'
    local git_upstream="${1:-@{u\}}"
    local git_local=''
    git_local="$(git rev-parse "${git_current_branch}")"
    local git_remote=''
    git_remote="$(git rev-parse "${git_upstream}")"
    local git_base=''
    git_base="$(git merge-base \
        "${git_current_branch}" "${git_upstream}" \
    )"

    # Largely redundant, but just in case
    [[ "${git_upstream}" == '@{u}' ]] \
        && git_upstream="$(repo_resolve_upstream "${git_upstream}")"

    # Check local against upstream
    if [[ "${git_local}" == "${git_remote}" ]]; then
        log_msg 'INFO' 'Git local is same as remote'
        return 1
    elif [[ "${git_local}" == "${git_base}" ]]; then
        log_msg 'INFO' 'Git local is behind remote'
        repo_pull_rebase "${git_upstream}" \
            && return 0
    elif [[ "${git_remote}" == "${git_base}" ]]; then
        log_msg 'WARN' 'Git local is ahead of remote'

        # Leave choice with user
        local want_rebuild='Maybe'
        local -a rebuild_opts=( 'Yes' 'No' )
        printf '\nRebuild?\n'
        select want_rebuild in "${rebuild_opts[@]}"; do
            case "${want_rebuild}" in
                "${rebuild_opts[0]}")
                    repo_pull_rebase "${git_upstream}" \
                        && return 0
                    ;;
                "${rebuild_opts[1]}") return 1 ;;
            esac
        done
    else
        log_msg 'ABORT' 'Git histories have diverged'
        exit 1
    fi

    return 1
}

# Resolve upstream tracking name
repo_resolve_upstream() { # Parameters: upstream
    local upstream="${1:-@{u\}}"
    [[ "${upstream}" == '@{u}' ]] \
        && upstream="$( \
                git for-each-ref --format='%(upstream:short)' \
                    "$(git symbolic-ref -q HEAD)"
            )"

    printf '%s' "${upstream}"
}

################################################################################

# Entry point
main() { # Parameters: [flags]
    # Set defaults
    local git_dir="${HOME}/git/ripgrep"
    local upstream='@{u}'
    local force_rebuild='reasons'
    local strip_bin='strip'
    verbosity=2

    # Process flag arguments first in case help is sought
    local flag=''
    while getopts 'hv:fd:u:p' flag; do
        case "${flag}" in
            h)  usage; exit 0 ;;
            v)
                verbosity="${OPTARG}"
                [[ ! "${verbosity}" =~ ^[0-9]$ ]] \
                    && { usage; exit 1; }
                ;;
            f)  force_rebuild='force' ;;
            d)  git_dir="${OPTARG}" ;;
            u)  upstream="${OPTARG}" ;;
            p)  strip_bin='keep' ;;
            *)  usage; exit 1 ;;
        esac
    done

    # Move past flag arguments
    shift "$(( OPTIND - 1 ))"

    # Fail as early as possible
    log_msg 'INFO' 'Checking prerequisites'

    # Bash version check
    if [[ -z "${BASH_VERSION}" ]] \
        || (( "${BASH_VERSION:0:1}" < 4 || "${BASH_VERSION:2:1}" < 4 )); then
            log_msg 'ERROR' 'Minimum Bash version 4.4 required'
            exit 1
    fi

    # Check for presence of folling executables in PATH
    require 'date' 'basename' 'unbuffer' 'rustup' 'git' 'cargo' \
        'column' 'sed' 'strip' \
            && log_msg 'INFO' 'Requirements satisfied'

    # Enter specified directory
    cd "${git_dir}" \
        || { log_msg 'ERROR' "Could not cd to ${git_dir}"; exit 1; }

    # Navigate to ripgrep Git root directory
    local git_dir_top
    git_dir_top="$(git rev-parse --show-toplevel)"
    if [[ "$(basename -- "${git_dir_top}")" != 'ripgrep' ]]; then
        log_msg 'ERROR' "${git_dir} is not within local ripgrep Git tree"
        exit 1
    fi
    cd "${git_dir_top}" \
        || { log_msg 'ERROR' "Could not cd to ${git_dir_top}"; exit 1; }

    local reasons=0
    [[ "${force_rebuild}" == 'force' ]] \
        && (( ++reasons ))

    # Get ripgrep remote status
    log_msg 'INFO' 'Checking with ripgrep remote for changes'
    (( verbosity > 1 )) \
        && git remote update

    # Get upstream tracking name
    [[ "${upstream}" == '@{u}' ]] \
        && upstream="$(repo_resolve_upstream "${upstream}")"

    # Try updating Rust
    rust_update \
        && (( ++reasons ))

    # Try pulling from ripgrep upstream, if required
    [[ "${force_rebuild}" != 'force' ]] \
        && repo_check "${upstream}" \
            && (( ++reasons ))

    # Try rebuilding ripgrep
    if (( reasons > 0 )); then
        ripgrep_rebuild "${strip_bin}"
    else
        log_msg 'INFO' 'ripgrep rebuild not required' 'force'
    fi
}

main "${@}"
