#!/usr/bin/env bash

# Update Rust, pull changes from ripgrep upstream; rebuild, if necessary
# Tested with Rust nightly

################################################################################

# # Trace live execution
# set -o xtrace

# Calm down a bit
set +o errexit

# Source Bash utilities, if possible
export bash_utils="${HOME:=/home/slaiyer}/bin/bash_utils.sh"
# shellcheck source=/home/slaiyer/bin/bash_utils.sh
if [[ ! -e "${bash_utils}" ]] || ! . "${bash_utils}"; then
    printf '[ERROR] Could not source %s\n' "${bash_utils}" 1>&2
    exit 1
fi

# Update Rust, if possible
rust_update() {
    log_msg 'INFO' 'Checking for updates to Rust'

    # Duplicate stdout and stderr
    exec 3>&1
    exec 4>&2

    # Copy rustup output streams without grep knowing about it
    unbuffer rustup update 1>&3 2>&4 3>&- 4>&- \
        |& grep -q -F 'updated'

    # Save grep exit status
    ret_val="${?}"

    # Close duplicated file descriptors
    exec 3>&-
    exec 4>&-

    return "${ret_val}"
}

# Pull fresh changes from ripgrep upstream, rebuild, and run tests
ripgrep_rebuild() { # Parameters: strip_bin
    log_msg 'INFO' 'Pulling updates from ripgrep upstream'
    git pull --rebase \
        || { log_msg 'ERROR' 'Git pull failed'; exit 1; }

    log_msg 'INFO' 'Building ripgrep'
    env RUSTFLAGS='-C target-cpu=native' \
        cargo build --release --features 'simd-accel avx-accel' \
            || { log_msg 'ERROR' 'Cargo build failed'; exit 1; }

    log_msg 'INFO' 'Testing new build'
    cargo test --all \
        || { log_msg 'WARN' 'Cargo test failed'; exit 1; }

    exe_path='./target/release/rg'

    log_msg 'INFO' 'Build successful' 'force'
    "${exe_path}" --version \
        || { log_msg 'WARN' 'Could not query ripgrep version'; exit 1; }

    log_msg 'INFO' 'Stripping executable'
    [[ "${1:-strip}" == 'strip' ]] \
        && {
            log_msg 'INFO' "Before strip:"$'\n\t'"$(ls -lF "${exe_path}")"
            strip -p -s "${exe_path}"
            log_msg 'INFO' "After strip:"$'\n\t'"$(ls -lF "${exe_path}")"
        }
}

# Check if upstream has updates
repo_update() { # Parameters: upstream_branch
    log_msg 'INFO' 'Checking ripgrep Git local against upstream'

    (( verbosity > 1 )) \
        && git remote update

    local git_current_branch='@{0}'
    local git_upstream_tracking="${1:-@{u\}}"
    local git_local=''
    git_local="$(git rev-parse "${git_current_branch}")"
    local git_remote=''
    git_remote="$(git rev-parse "${git_upstream_tracking}")"
    local git_base=''
    git_base="$(git merge-base \
        "${git_current_branch}" "${git_upstream_tracking}" \
    )"

    # Check local against upstream
    if [[ "${git_local}" == "${git_remote}" ]]; then
        log_msg 'INFO' 'Git local is same as remote'
        return 1
    elif [[ "${git_local}" == "${git_base}" ]]; then
        log_msg 'INFO' 'Git local is behind remote'
        return 0
    elif [[ "${git_remote}" == "${git_base}" ]]; then
        log_msg 'WARN' 'Git local is ahead of remote'
        local want_rebuild='Maybe'

        # read -rp '\nRebuild? [y/N]: ' want_rebuild
        # [[ "${want_rebuild^^}" =~ ^Y ]] \
        #     && return 0
        # return 1

        local -a rebuild_opts=( 'Yes' 'No' )
        printf '\nRebuild?\n'
        select want_rebuild in "${rebuild_opts[@]}"; do
            case "${want_rebuild}" in
                "${rebuild_opts[0]}") return 0 ;;
                "${rebuild_opts[1]}") return 1 ;;
            esac
        done
    else
        log_msg 'ABORT' 'Git histories have diverged'
        exit 1
    fi

    return 1
}

# Print help message
usage() {
    local help_fmt="${sqo}-h${sqc}"
    local help_msg="${d}Print this help message${n}"
    local verb_fmt="${sqo}-v ${u}0${n}..${u}2${n}${sqc}"
    local verb_msg="${d}Control output verbosity${n}"
    local force_fmt="${sqo}-f${sqc}"
    local force_msg="${d}Force ripgrep rebuild${n}"
    local src_fmt="${sqo}-d ${i}<ripgrep_git_dir>${n}${sqc}"
    local src_msg="${d}Specify path to ripgrep git local directory${n}"
    local branch_fmt="${sqo}-u ${i}<upstream_branch>${n}${sqc}"
    local branch_msg="${d}Specify ripgrep Git remote tracking branch${n}"
    local nostrip_fmt="${sqo}-p${sqc}"
    local nostrip_msg="${d}Do not strip executable post build step${n}"
    local -A prog_params=(
        ["${help_fmt}"]="${help_msg}"
        ["${verb_fmt}"]="${verb_msg}"
        ["${force_fmt}"]="${force_msg}"
        ["${src_fmt}"]="${src_msg}"
        ["${branch_fmt}"]="${branch_msg}"
        ["${nostrip_fmt}"]="${nostrip_msg}"
    )

    printf 'Usage:\n\t%s\n' "${b}$(basename -- "${0}")${n}" 1>&2

    local text=''
    for flag in "${!prog_params[@]}"; do
        text="${text}${flag}|${prog_params[${flag}]}"$'\n'
    done

    printf '%s' "${text}" \
        | column -t -s '|' \
        | sed -u 's/^/\t\t/' 1>&2
}

################################################################################

# Entry point
main() { # Parameters: [flags]
    # Set defaults
    local git_dir="${HOME}/git/ripgrep"
    local upstream_branch='@{u}'
    local reasons=0
    local strip_bin='strip'
    verbosity=2

    # Process flag arguments
    local flag=''
    while getopts 'hv:fd:u:p' flag; do
        case "${flag}" in
            h)  usage; exit 0 ;;
            v)
                verbosity="${OPTARG}"
                [[ ! "${verbosity}" =~ ^[0-9]$ ]] \
                    && { usage; exit 1; }
                ;;
            f)  (( ++reasons )) ;;
            d)  git_dir="${OPTARG}" ;;
            u)  upstream_branch="${OPTARG}" ;;
            p)  strip_bin='keep' ;;
            *)  usage; exit 1 ;;
        esac
    done

    # Move past flag arguments
    shift "$(( OPTIND - 1 ))"

    # Fail as early as possible
    log_msg 'INFO' 'Checking prerequisites'
    require 'date' 'basename' 'mkfifo' 'unbuffer' 'rustup' 'git' \
        'cargo' 'column' 'sed' 'strip' \
            && log_msg 'INFO' 'Requirements satisfied'

    # Enter specified directory
    cd "${git_dir}" \
        || { log_msg 'ERROR' "Could not cd to ${git_dir}"; exit 1; }

    # Navigate to ripgrep Git root directory
    local git_dir_top
    git_dir_top="$(git rev-parse --show-toplevel)"
    if [[ "$(basename -- "${git_dir_top}")" != 'ripgrep' ]]; then
        log_msg 'ERROR' "${git_dir} is not within local ripgrep Git tree"
        exit 1
    fi
    cd "${git_dir_top}" \
        || { log_msg 'ERROR' "Could not cd to ${git_dir_top}"; exit 1; }

    # Try updating Rust
    rust_update \
        && (( ++reasons ))

    # Try updating local Git clone
    repo_update "${upstream_branch}" \
        && (( ++reasons ))

    # Try rebuilding ripgrep
    if (( reasons > 0 )); then
        ripgrep_rebuild "${strip_bin}"
    else
        log_msg 'INFO' 'ripgrep rebuild not required' 'force'
    fi
}

main "${@}"
